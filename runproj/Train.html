<!doctype html>
<html lang="en"><head><meta charset="utf-8"/><title>Train route tester</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:18px}
  #stops{font-family:monospace;white-space:pre-wrap;margin:6px 0}
  #stops button{margin:2px;padding:4px 6px;font-family:inherit}
  input{width:320px}
  pre{background:#f4f4f4;padding:10px;border-radius:6px}
</style>
</head><body>
<h2>Train route tester (loco-only shortest path via API)</h2>

<h3>Available stops</h3>
<p id="stops">loading...</p>

<label for="route">Enter route token(s):</label>
<input id="route" placeholder='Examples: "A1", "A", "M1 MAIN A1"'>
<div style="margin-top:8px">
  <button id="compute">Compute (API)</button>
  <button id="local">Compute (local fallback)</button>
</div>
<pre id="out" style="margin-top:12px">—</pre>

<script>
/* derive the same topology as Program.cs */
(function(){
  const sidingLengths = { A:2, B:3, C:1, D:2, E:1 };

  function buildGraph(){
    const g = {};
    for (const s in sidingLengths){
      const n = sidingLengths[s];
      for (let i=0;i<n;i++){
        const name = s + i;
        g[name] = g[name] || new Set();
        if (i>0) g[name].add(s+(i-1));
        if (i<n-1) g[name].add(s+(i+1));
      }
    }
    g['MAIN'] = g['MAIN'] || new Set();
    for (const s in sidingLengths){
      const tail = s + (sidingLengths[s]-1);
      g['MAIN'].add(tail);
      g[tail].add('MAIN');
    }
    g['M1'] = g['M1'] || new Set(['MAIN']);
    g['M2'] = g['M2'] || new Set(['MAIN']);
    g['MAIN'].add('M1'); g['MAIN'].add('M2');
    const res = {};
    Object.keys(g).forEach(k => res[k]=Array.from(g[k]));
    return res;
  }

  const graph = buildGraph();

  // show all stops (nodes) — MAIN,M1,M2 first then sorted by siding
  const stops = Object.keys(graph).sort((a,b)=>{
    if (a==='MAIN') return -1;
    if (b==='MAIN') return 1;
    if (a==='M1' || a==='M2') return -1;
    if (b==='M1' || b==='M2') return 1;
    return a.localeCompare(b, undefined, {numeric:true});
  });

  const stopsEl = document.getElementById('stops');
  // render stops as clickable buttons so user can pick one if unsure
  function renderStops() {
    stopsEl.innerHTML = '';
    stops.forEach(s => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = s;
      btn.addEventListener('click', () => {
        const input = document.getElementById('route');
        // insert or append token depending on current value
        input.value = input.value ? (input.value + ' ' + s) : s;
        input.focus();
      });
      stopsEl.appendChild(btn);
    });
  }
  renderStops(); // initial render

  // shortest path helper (local fallback)
  function shortestPath(from,to){
    if (!graph[from] || !graph[to]) return [];
    const q = [from], parent = {[from]: null};
    while(q.length){
      const u = q.shift();
      if (u === to) break;
      for(const v of graph[u]) if (!(v in parent)){ parent[v]=u; q.push(v); }
    }
    if (!(to in parent)) return [];
    const p = []; for(let cur = to; cur != null; cur = parent[cur]) p.push(cur);
    return p.reverse();
  }

  // helper: show stops in output when user has no idea
  function showStopsInOutput() {
    document.getElementById('out').textContent = 'Available stops:\n' + stops.join(', ');
  }

  // local button
  document.getElementById('local').addEventListener('click', ()=>{
    const raw = (document.getElementById('route').value||'').trim().toUpperCase();
    if (!raw) { showStopsInOutput(); return; } // show list when input empty
    const tokens = raw.split(/[,\s\t]+/).filter(Boolean);
    const nonLoc = tokens.filter(t=> t!=='M1' && t!=='MAIN' && t!=='M2');
    let dest = null;
    for(const t of nonLoc) if (t.length===1 && sidingLengths[t]){ dest = t + (sidingLengths[t]-1); break; }
    if (!dest) for(const t of nonLoc) if (graph[t]){ dest = t; break; }
    if (!dest) for(const t of tokens){ if (t.length===1 && sidingLengths[t]){ dest = t + (sidingLengths[t]-1); break; } if (graph[t]){ dest = t; break; } }
    if (!dest){ document.getElementById('out').textContent='No dest recognized'; return; }
    const path = shortestPath('M1', dest);
    if (path.length === 0){ document.getElementById('out').textContent = `No path M1 -> ${dest}`; return; }
    let txt = `Loco-only shortest path M1 -> ${dest}: ${path.join(' -> ')}\n\n`;
    for (let i=1;i<path.length;i++) txt += `MOVE ${path[i-1]}->${path[i]}\n`;
    txt += '\nLoco reached destination.';
    document.getElementById('out').textContent = txt;
  });

  // API button
  document.getElementById('compute').addEventListener('click', ()=>{
    const raw = (document.getElementById('route').value||'').trim();
    if (!raw) { showStopsInOutput(); return; } // show list when input empty
    fetch('http://localhost:5000/route', {
      method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ input: raw })
    })
    .then(r=>r.json())
    .then(j=>{
      if (j.error) { document.getElementById('out').textContent = j.error; return; }
      const txt = `Path: ${j.path.join(' -> ')}\n\n${(j.moves||[]).join('\n')}\n\nLoco reached destination.`;
      document.getElementById('out').textContent = txt;
    })
    .catch(e => document.getElementById('out').textContent = 'API error: ' + e);
  });
})();
</script>
</body></html>